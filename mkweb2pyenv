#!/usr/bin/env python
import gluon
from gluon.fileutils import untar
import os
import sys

"""
Documentation Author: Christopher Steel on behalf of Voice of Access
Copyright: Copyrighted (c) by Massimo Di Pierro (2007-2011)

If you are just completing a big learning curve for virtualenv, pip and/or
web2py you might want to skip this command for now and run the web2py_clone
command instead and manipulate your web2py virtualenv the "classic way".

Otherwise please read on and enjoy this related public service announcement...

"D. P. Gumby - My Brain Hurts! "
http://www.youtube.com/watch?v=IIlKiRPSNGA

Contrary to popular belief mkweb2pyenv does not in facg make nor create a
virtualenv.

mkweb2pyenv untars a populated and a kind of "headless" web2py
"applications" directory in the target directory specified on the
command line. If no directory argument is supplied it will attempt
to create an applications directory in whatever directory you happen
to be in when you run the command.

While mkweb2pyenv is a real gem (pun intended) of a command is has a
rather (very?) misleading name, especially when taken within the context
of virtual environments and the accepted definition of virtualenvs.

The command does not create a virtual environment, what it does is very handy
for developers and testers as you can create multiple populated Web2py
"applications" directories at specified paths.

By the same token, it can be kind of confusing for those who are new to
virtual environments or the commands related to running a "pip install web2py"
created setup.

For example running:

mkweb2pyenv /home/my_user/django        # no that is not a typo!

results in the creation of:

/home/my_user/django

and our new directory django contains a populated Web2py applications
directory as well as the following files.

    VERSION
    deposit
    httpserver.log
    logs
    parameters_8000.py
    site-packages
    splashlogo.gif
    welcome.w2p

(Notice that most of what makes up Web2py seems to be missing!)

If we run our command a second time with:

mkweb2pyenv /home/my_user/web2py

We will end up with a second "functional" populated applications folder.

Are you a bit confused yet?

Now you can "launch" Web2py and using the corresponding applications folder
by moving into the targeted applications folder and launching the runweb2py
command.

So both:

cd /home/my_user/django
runweb2py

and
cd /home/my_user/django
runweb2py

Will launch the same version of web2py but make use of the different
application directories.

The "standard" contents of the Web2py directory (at least most of it) is
used by both "applications" directories and is still present but is located
in our virtualenv Python site-packages root and site-packages/gluon folders.

or

./lib/python2.x/site-packages/
./lib/python2.x/site-packages/gluon

This is kind of cool when you understand what is going on, but borders
on foobar for the disoriented and uninitiated.

Have fun!

"""

def main():
    """
    untars the web2py "applications" directory and selected files to the 
    target path.

    While this command is run "inside" of a virtualenv it does not create 
    or make a virtualenv and the tar file called env.tar contains standard
    files that do not constitute an environment.

    The command can be run more than once inside of the same virtualenv and
    used to create two functioning sets of files that have an applicaitons 
    directory, but both user the same virtualenv and the same web2py libraries
    modules and so on and so forth.

    Kind of twisted but in a cool kind of way...
    """
    path = gluon.__path__
    out_path = os.getcwd()
    try:
        if sys.argv[1] and os.path.exists(sys.argv[1]):
            out_path = sys.argv[1]
        else:
            os.mkdir(sys.argv[1])
            out_path = sys.argv[1]
    except:
        pass
    try:
        print "Creating a web2py env in: " + out_path
        untar(os.path.join(path[0],'env.tar'),out_path)
    except:
        print "Failed to create the web2py env"
        print "Please reinstall web2py from pip"

if __name__ == '__main__':
    main()
