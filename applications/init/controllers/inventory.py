#CONTROLLER

@auth.requires_membership('dealers')
def index():
	
	paging = PAGINATE(request.args(0),request.vars['view'])
	
	sortby = request.vars['sortby']
	sorting = [["make-up", "make-down"], ["model-up", "model-down"], ["trim-up", "trim-down"], ["year-up", "year-down"] ]
	orderby = ~db.auction_request_offer.modified_on
	#DB LEVEL SORTING 
	if sortby == "make-up":
		orderby = db.auction_request_offer.make #this query causes referencing of two tables, so a join has occured
	if sortby == "make-down":
		orderby = ~db.auction_request_offer.make
	if sortby == "model-up":
		orderby = db.auction_request_offer.model
	if sortby == "model-down":
		orderby = ~db.auction_request_offer.model
	if sortby == "trim-up":
		orderby = db.auction_request_offer.trim_name
	if sortby == "trim-down":
		orderby = ~db.auction_request_offer.trim_name
	if sortby == "year-up":
		orderby = db.auction_request_offer.year
	if sortby == "year-down":
		orderby = ~db.auction_request_offer.year
		
	show = request.vars['show']
	show_list = sorted( map(lambda x: x[0],VEHICLE_STATES) + ["all"])
	query = (db.auction_request_offer.id > 0) & (db.auction_request_offer.owner_id == auth.user_id) #must
	#left = db.auction_request.on(db.auction_request_offer.auction_request == db.auction_request.id)
	if (not show in [None, "all"]) and (show in show_list[:2]): #all is inert
		query &= db.auction_request_offer.status.contains(show)

	my_inventory = db(query).select(
		#left=left, 
		limitby = paging['limitby'],
		orderby = orderby
	)
	
	for each_vehicle in my_inventory:
		int_ext_colors = GET_OFFER_ROW_INT_EXT_COLORS(each_vehicle)
		each_vehicle['interior_color'] = int_ext_colors[0]
		each_vehicle['exterior_color'] = int_ext_colors[1]
	
	#for each_brand in ALL_BRANDS_LIST:
	#
	#	make_details = EDMUNDS_CALL(MAKE_URI%(each_brand, year))
	
	response.title="My inventory"
	
	return dict(my_inventory=my_inventory, sorting=sorting, show_list=show_list, **paging)
	
@auth.requires(request.args(0))
@auth.requires_membership('dealers')
def vin_decode():
	clean = "".join(request.args[0].split()) #http://stackoverflow.com/questions/3739909/how-to-strip-all-whitespace-from-string
	vehicle_info = EDMUNDS_CALL(VIN_DECODE_URI % clean)
	if vehicle_info:
		try:
			make = vehicle_info['make']['niceName']
			model = vehicle_info['model']['niceName']
			year = vehicle_info['years'][0]['year']
			print year, make, model
			redirect(URL('inventory', 'vehicle', args=[year,make,model]) )
		except:
			pass
	session.flash = "@Failed to decode VIN number! Please double-check VIN and try again."
	redirect(URL('inventory', 'index'))
	
	
@auth.requires(request.args(0) and request.args(1) and request.args(2))
@auth.requires_membership('dealers')
def vehicle():
	
	year = request.args[0] 
	make = request.args[1] #VALIDATE #done via digitally signed url
	model = request.args[2]
	db.auction_request_offer.year.default=year
	db.auction_request_offer.make.default=make
	db.auction_request_offer.model.default=model
	#db.auction_request_offer.created_on.default=request.now #moved to model
	
	edit_record = db(db.auction_request_offer.id == int(request.args(3) or -1)).select().last() #can't have none ID so it's safe to use request.args
	edit = bool(edit_record)
	
	model_styles = EDMUNDS_CALL(STYLES_URI%(make, model, year))['styles'] #GET_STYLES_BY_MAKE_MODEL_YEAR instead to limit years
	
	#print model_styles
	
	if not model_styles:
		session.message='@Invalid Year!'
		redirect(URL('index.html'))
		
	trims = []
	for each_style in model_styles:
		trims.append(
			[each_style['id'], each_style['name']]
		)	
	trims.sort()

	db.auction_request_offer.trim.requires = IS_IN_SET(trims, zero=None)
	#trim_data = json.loads(auction_request_offer.trim_data)
	
	color_codes = []
	option_codes= [] #needed for SQLFORM to create proper IS_IN_SET widget
	if not request.post_vars: #if get: needed to prevent use of incorrect color_codes
		if edit:
			GET_COLOR_CODES(json.loads(edit_record['trim_data'])) #session.color_codes needed to prefill edit form data. Also make sure this isn't done in form submit, because trim_data might be different from the previous record.
			GET_OPTION_CODES(json.loads(edit_record['trim_data']))
		else:
			session.color_codes = []
			session.option_codes = []
		
	if session.color_codes: #generated by ajax/colors
		color_codes = session.color_codes #this is to update IS_IN_SET to the changes returned by the ajax function (stored in session so it can be used cross site), which is called every time user changes trim choices field
	if session.option_codes:
		option_codes = session.option_codes #["200466570", "17\" Alloy", "17\" x 7.0\" alloy wheels with 215/45R17 tires", "Exterior", "exterior"]
	
	db.auction_request_offer.colors.requires = [IS_IN_SET( map(lambda each_color: [each_color[0],  each_color[1]], color_codes), multiple=True)] #OLD [IS_IN_SET(color_codes, multiple=True, zero=None), IS_NOT_EMPTY(error_message='pick at least one color')]
	db.auction_request_offer.colors.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
	#db.auction_request_offer.options.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
		
	db.auction_request_offer.options.requires = [IS_IN_SET( map(lambda each_option: [each_option[0],  each_option[1]], option_codes), multiple=True)] #requires needs [id, name]'s
	db.auction_request_offer.options.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
	
	db.auction_request_offer.auction_request.default = None
	db.auction_request_offer.owner_id.default = auth.user_id
	
	form = SQLFORM(db.auction_request_offer, record = edit_record.id if edit else None, _class="form-horizontal") #to add class to form #http://goo.gl/g5EMrY
	
	if form.process(keepvalues=True, onvalidation=lambda form:VALIDATE_VEHICLE(form, make, model, year, 'auction_request_offer', _dealer=True), hideerror=True, message_onfailure="@Errors in form. Please check it out.").accepted: #hideerror = True to hide default error elements #change error message via form.custom
		pass
		
	response.title="Add a vehicle to your inventory"
	return dict(form = form, year=year, make=make, model=model, edit=edit, edit_record=edit_record) #options=options, option_codes=option_codes,) #msrp_by_id=msrp_by_id, )
