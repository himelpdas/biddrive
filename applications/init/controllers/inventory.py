#CONTROLLER

@auth.requires_membership('dealers')
def index():
	
	paging = PAGINATE(request.args(0),request.vars['view'])
	
	sortby = request.vars['sortby']
	sorting = [["make-up", "make-down"], ["model-up", "model-down"], ["trim-up", "trim-down"], ["year-up", "year-down"] ]
	orderby = ~db.auction_request_offer.modified_on
	#DB LEVEL SORTING 
	if sortby == "make-up":
		orderby = db.auction_request_offer.make #this query causes referencing of two tables, so a join has occured
	if sortby == "make-down":
		orderby = ~db.auction_request_offer.make
	if sortby == "model-up":
		orderby = db.auction_request_offer.model
	if sortby == "model-down":
		orderby = ~db.auction_request_offer.model
	if sortby == "trim-up":
		orderby = db.auction_request_offer.trim_name
	if sortby == "trim-down":
		orderby = ~db.auction_request_offer.trim_name
	if sortby == "year-up":
		orderby = db.auction_request_offer.year
	if sortby == "year-down":
		orderby = ~db.auction_request_offer.year
		
	show = request.vars['show']
	show_list = sorted(['unsold', 'sold', 'all'])
	query = (db.auction_request_offer.id > 0) & (db.auction_request_offer.owner_id == auth.user_id) #must
	#left = db.auction_request.on(db.auction_request_offer.auction_request == db.auction_request.id)
	if show in show_list[:2]: #all is inert
		query &= db.auction_request_offer.status == show

	my_inventory = db(query).select(
		#left=left, 
		limitby = paging['limitby'],
		orderby = orderby
	)
	
	for each_vehicle in my_inventory:
		int_ext_colors = GET_OFFER_ROW_INT_EXT_COLORS(each_vehicle)
		each_vehicle['interior_color'] = int_ext_colors[0]
		each_vehicle['exterior_color'] = int_ext_colors[1]
	
	response.title="My inventory"
	return dict(my_inventory=my_inventory, sorting=sorting, show_list=show_list, **paging)
	
@auth.requires(request.args(0) and request.args(1) and request.args(2))
@auth.requires_membership('dealers')
def vehicle():
	
	year = request.args[0] 
	make = request.args[1] #VALIDATE #done via digitally signed url
	model = request.args[2]
	auction = request.args(3)
	db.auction_request_offer.year.default=year
	db.auction_request_offer.make.default=make
	db.auction_request_offer.model.default=model
	#db.auction_request_offer.created_on.default=request.now #moved to model
	
	model_styles = GET_STYLES_BY_MAKE_MODEL_YEAR(make, model, year)
	
	if not model_styles:
		session.message='Invalid Year!'
		redirect(URL('index.html'))
		
	trims = []
	for each_style in model_styles:
		trims.append(
			[each_style['id'], each_style['name']]
		)	
	trims.sort()

	db.auction_request_offer.trim.requires = IS_IN_SET(trims, zero=None)
	#trim_data = json.loads(auction_request_offer.trim_data)
	
	color_codes = []
	option_codes= [] #needed for SQLFORM to create proper IS_IN_SET widget
	if not request.post_vars: #if get: needed to prevent use of incorrect color_codes
		session.color_codes = []
		session.option_codes = []
	if session.color_codes: #generated by ajax/colors
		color_codes = session.color_codes #this is to update IS_IN_SET to the changes returned by the ajax function (stored in session so it can be used cross site), which is called every time user changes trim choices field
	if session.option_codes:
		option_codes = session.option_codes #["200466570", "17\" Alloy", "17\" x 7.0\" alloy wheels with 215/45R17 tires", "Exterior", "exterior"]
	
	db.auction_request_offer.colors.requires = [IS_IN_SET( map(lambda each_color: [each_color[0],  each_color[1]], color_codes), multiple=True)] #OLD [IS_IN_SET(color_codes, multiple=True, zero=None), IS_NOT_EMPTY(error_message='pick at least one color')]
	db.auction_request_offer.colors.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
	#db.auction_request_offer.options.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
		
	db.auction_request_offer.options.requires = [IS_IN_SET( map(lambda each_option: [each_option[0],  each_option[1]], option_codes), multiple=True)] #requires needs [id, name]'s
	db.auction_request_offer.options.widget=SQLFORM.widgets.multiple.widget #multiple widget will not appear when IS_IN_SET is combined with other validators
	
	db.auction_request_offer.auction_request.default = None
	db.auction_request_offer.owner_id.default = auth.user_id
	
	form = SQLFORM(db.auction_request_offer, _class="form-horizontal") #to add class to form #http://goo.gl/g5EMrY
	
	if form.process(keepvalues=True, onvalidation=lambda form:VALIDATE_VEHICLE(form, make, model, year, 'auction_request_offer', _dealer=True), hideerror=True, message_onfailure="@Errors in form. Please check it out.").accepted: #hideerror = True to hide default error elements #change error message via form.custom
		pass
		
	response.title="Add a vehicle to your inventory"
	return dict(form = form, year=year, make=make, model=model) #options=options, option_codes=option_codes,) #msrp_by_id=msrp_by_id, )
